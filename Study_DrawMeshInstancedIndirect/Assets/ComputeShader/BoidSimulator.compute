// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel BoidsCalculation
// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

struct BoidsData {
    float3 position;
    float3 velocity;
};

RWStructuredBuffer<BoidsData> boidsData;

// Boidsパラメータ
float cohesionForce;
float separationForce;
float alignmentForce;

float cohesionDistance;
float separationDistance;
float alignmentDistance;

float cohesionAngle;
float separationAngle;
float alignmentAngle;

float boundaryForce;
float boundaryRange;

float maxVelocity;
float minVelocity;

int instanceCount;

float maxForce;

float deltaTime;

// 速度と座標から角度を求める
float CalcAngle(float3 velocity, float3 posX, float3 posY) {

    float3 vec = posY - posX;

    return acos(dot(normalize(velocity), normalize(vec)));

}

// 距離の2乗を求める
float CalcSqrDistance(float3 posX, float3 posY) {

    float3 vec = posY - posX;

    return dot(vec, vec);

}

// ベクトルの大きさを制限する
float3 limit(float3 vec, float max)
{
	float length = sqrt(dot(vec, vec)); // 大きさ
	return (length > max && length > 0) ? vec.xyz * (max / length) : vec.xyz;
}

// 壁に当たった時に逆向きの力を返す
float3 avoidWall(float3 position)
{
float3 wc = float3(0, 0, 0);
float3 ws = float3(boundaryRange, boundaryRange, boundaryRange);
float3 acc = float3(0, 0, 0);
// x
acc.x = (position.x < wc.x - ws.x * 0.5) ? acc.x + 1.0 : acc.x;
acc.x = (position.x > wc.x + ws.x * 0.5) ? acc.x - 1.0 : acc.x;
// y
acc.y = (position.y < wc.y - ws.y * 0.5) ? acc.y + 1.0 : acc.y;
acc.y = (position.y > wc.y + ws.y * 0.5) ? acc.y - 1.0 : acc.y;
// z
acc.z = (position.z < wc.z - ws.z * 0.5) ? acc.z + 1.0 : acc.z;
acc.z = (position.z > wc.z + ws.z * 0.5) ? acc.z - 1.0 : acc.z;
return acc;
}

[numthreads(256, 1, 1)]
void BoidsCalculation(uint id : SV_DISPATCHTHREADID) {

    float3 posX = boidsData[id.x].position;
    float3 velX = boidsData[id.x].velocity;

    float3 cohesionPositionSum = float3(0, 0, 0);
    float3 separationPositionSum = float3(0, 0, 0);
    float3 alignmentVelocitySum = float3(0, 0, 0);

    int cohesionCount = 0;
    int alignmentCount = 0;

    for(uint i = 0; i < instanceCount; ++i) {
        if(i == id.x)
            continue;

        float3 posY = boidsData[i].position;
        float3 velY = boidsData[i].velocity;

        float sqrDistance = CalcSqrDistance(posX, posY);
        float angle = CalcAngle(velX, posX, posY);

        if(sqrDistance < cohesionDistance && angle < cohesionAngle) {
            cohesionPositionSum += posY;
            cohesionCount++;
        }
        if(sqrDistance < separationDistance && angle < separationAngle) {
            separationPositionSum += posX - posY;
        }
        if(sqrDistance < alignmentDistance && angle < alignmentAngle) {
            alignmentVelocitySum += velY;
            alignmentCount++;
        }

    }

    float3 cohesion = float3(0, 0, 0);
    float3 separation = separationPositionSum;
    float3 alignment = float3(0, 0, 0);
    float3 boundary = float3(0, 0, 0);

    if(cohesionCount != 0)
        cohesion = (cohesionPositionSum / cohesionCount - posX) * cohesionForce;
    
    if(alignmentCount != 0) 
        alignment = (alignmentVelocitySum / alignmentCount - velX) * alignmentForce;
    
    separation *= separationForce;

    float sqrDistFromCenter = dot(posX, posX);
    if(sqrDistFromCenter > boundaryRange)
        boundary = -boundaryForce * posX * (sqrDistFromCenter - boundaryRange) / sqrDistFromCenter;

    float3 acc = avoidWall(posX) * boundaryForce;

    cohesion = limit(cohesion, maxForce);
    separation = limit(separation, maxForce);
    alignment = limit(alignment, maxForce);

    velX += (cohesion + separation + alignment + acc) * deltaTime;


    float velXScale = length(velX);

    if(velXScale < minVelocity) {
        velX = minVelocity * normalize(velX);
    }
    else if (velXScale > maxVelocity) {
        velX = maxVelocity * normalize(velX);
    }

    boidsData[id.x].velocity = velX;
    boidsData[id.x].position += velX;

}
